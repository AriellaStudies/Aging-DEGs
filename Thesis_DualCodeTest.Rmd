---
title: "ThesisTesting_21.01"
output:
  html_document:
    theme: darkly
    highlight: zenburn
---

# Version info: R 3.2.3, Biobase 2.30.0, GEOquery 2.40.0, limma 3.26.8
################################################################
# 0. Setup

Special GEOquery package
```{r eval=FALSE}
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("GEOquery")
```
Other Packages
```{r eval=FALSE}
install.packages('limma')
install.packages('umap')
install.packages("reticulate")
install.packages("homologene")
install.packages('ggplot2')
```
Open Libraries
```{r include=FALSE}
library(GEOquery)
library(limma)
library(umap)
library(reticulate)
library(knitr)
library(homologene)
library(ggplot2)
```
Install Python Packages
```{r cache=TRUE, eval=FALSE}
py_install("pandas")
py_install("regex")
```
Global Options (not in use)
```{r include=FALSE}
knitr::opts_chunk$set(class.source = "bg-info")
```
Python Packages
```{python}
import pandas as pd
import regex as re
```

# 1. Dataset Management (Python)
NCBI GEO was searched for expression datasets on 03/02/2021, filtered to mammalian species with age sets, with 221 results. Results were exported as a detailed text file, then parsed into a dataframe using Python below.
```{python message = FALSE, warning=FALSE}
pattern_organism = re.compile(r"\bOrganism\w*\b")
pattern_GSE = re.compile(r"\bPlatform\w*\b")

list_organism = []
list_GSE = []
list_platform = []
with open("gds_result.txt","rt") as myfile:
    for line in myfile:
        if pattern_organism.search(line) != None:
            betterline = line.replace("Organism:\t","")
            bestline = betterline.replace("\n","")
            list_organism.append(bestline)
        if pattern_GSE.search(line) != None:
            GSE = line.split("Series: ")[1].rsplit()[0]
            list_GSE.append(GSE)
            Platform = line.split("Platform: ")[1].rsplit()[0]
            list_platform.append(Platform)
list_of_lists = [list_GSE, list_organism, list_platform]
df_of_lists = pd.DataFrame(list_of_lists).transpose()
df_of_lists.columns = ["GSE","Organism","Platform"]
print(df_of_lists)
```
# 2. Dataset Management (Manual)

Each of the 221 candidate datasets are manually reviewed.
[IN PROGRESS] 

Datasets were excluded if two adult age-sets are not available, such as if the study is investigating a developmental process in the embryonic, postnatal, or juvenile period. Specifically, humans under 18yo, rats under 6mo, and mice under 3mo were not accepted. When more than two age-sets were available -- such as "young," "middle," and "old" -- comparisons between "middle" and "old" were prioritized. When a continuous set of ages were available, buffer regions were implemented, e.g. human age 30yo-60yo vs 70yo-90yo with 61-69yo excluded as a buffer region. Other, less common reasons were exclusion included datasets where control/untreated/wild-type groups were not available or when "age-sets" were actually time-points in short time-course experiments.

For all remaining datasets, the samples were categorized as young (0), old (1), or excluded (X) for the purposes of further processing. In addition, the tissue type under study was manually noted.

# 3. Calculate DEGs in each Dataset (R)

GEO2R Function
```{r cache=TRUE}
GEO2R <- function(GSE_number,platform_code,group_binaries,outputs){
  # load series and platform data from GEO
  gset <- getGEO(GSE_number, GSEMatrix =TRUE, AnnotGPL=TRUE)
  if (length(gset) > 1) idx <- grep(platform_code, attr(gset, "names")) else idx <- 1
  gset <- gset[[idx]]
  
  # make proper column names to match toptable 
  fvarLabels(gset) <- make.names(fvarLabels(gset))
  
  # group membership for all samples
  gsms <- group_binaries
  sml <- strsplit(gsms, split="")[[1]]
  
  # filter out excluded samples (marked as "X")
  sel <- which(sml != "X")
  sml <- sml[sel]
  gset <- gset[ ,sel]
  
  # log2 transformation
  ex <- exprs(gset)
  qx <- as.numeric(quantile(ex, c(0., 0.25, 0.5, 0.75, 0.99, 1.0), na.rm=T))
  LogC <- (qx[5] > 100) ||
            (qx[6]-qx[1] > 50 && qx[2] > 0)
  if (LogC) { ex[which(ex <= 0)] <- NaN
    exprs(gset) <- log2(ex) }
  
  # assign samples to groups and set up design matrix
  gs <- factor(sml)
  groups <- make.names(c("young","old"))
  levels(gs) <- groups
  gset$group <- gs
  design <- model.matrix(~group + 0, gset)
  colnames(design) <- levels(gs)
  
  fit <- lmFit(gset, design)  # fit linear model
  
  # set up contrasts of interest and recalculate model coefficients
  cts <- paste(groups[1], groups[2], sep="-")
  cont.matrix <- makeContrasts(contrasts=cts, levels=design)
  fit2 <- contrasts.fit(fit, cont.matrix)
  
  # compute statistics and table of top significant genes
  fit2 <- eBayes(fit2, 0.01)
  tT <- topTable(fit2, adjust="fdr", sort.by="B", number=outputs)
  
  tT <- subset(tT, select=c("ID","adj.P.Val","P.Value","t","B","logFC","Gene.symbol","Gene.title"))
  return(tT)
}
```

Function compounded to filter results by adjusted p<0.01
```{r}
GEO2R_pFiltered <- function(GSE_number,platform_code,group_binaries,outputs){
  tempTable <- GEO2R(GSE_number,platform_code,group_binaries,outputs)
  filtTable <- tempTable[tempTable$adj.P.Val<0.05,]
  dupTable <- filtTable[!duplicated(filtTable$Gene.symbol),]
  return(dupTable)
}
```

**DATASET CONTROL ZONE 1 OF 4**
*(These zones must be updated if adding datasets.)*

Execute functions on human datasets
(Note that some data-sets have more than 1000 p<0.01)
```{r cache = TRUE, message = FALSE, warning=FALSE}
#tT007 <- GEO2R_pFiltered("GSE58015","GPL571","000011111",1000)
tT009 <- GEO2R_pFiltered("GSE53890","GPL570","XXXXXXXX00000000000XX11111111111XXXXXXXXX",1000)
tT023 <- GEO2R_pFiltered("GSE38718","GPL570","0000000000000011111111",1000)
tT036 <- GEO2R_pFiltered("GSE28422","GPL570","00000000XXXXXXXXXXXXXXXXXXXXXXXX111111XXXXXXXXXXXXXXXXXX0000000XXXXXXXXXXXXXXXXXXXXXXX111111XXXXXXXXXXXXXXXXXX",1000)
tT044 <- GEO2R_pFiltered("GSE32719","GPL570","XXXXXXXXXXXXXX0000011111111",1000)
```

Execute function on mouse datasets
```{r cache = TRUE, message = FALSE, warning=FALSE}
tT000M <- GEO2R_pFiltered("GSE71868","GPL6885","11110000",1000)
tT008M <- GEO2R_pFiltered("GSE50821","GPL1261","00000XXXX11111",1000)
tT011M <- GEO2R_pFiltered("GSE55162","GPL1261","11110000",100)
tT014M <- GEO2R_pFiltered("GSE46646","GPL1261","XXXXXX000111",1000)
tT020M <- GEO2R_pFiltered("GSE49543","GPL339","XXXXXXXXX00000000000000000111111111111111",1000)
```

Convert mouse gene symbols to human gene symbols

Function:
```{r}
M2H <- function(mouse_tT){
  MouseSymbols = mouse_tT[,7]
  M2H_Symbols = mouse2human(MouseSymbols)
  tTMerge = merge(mouse_tT,M2H_Symbols,by.x = "Gene.symbol",by.y = "mouseGene")
  tTReordered = tTMerge[,c(2,3,4,5,6,7,9,8,1)]
  return(tTReordered)
}
```

**DATASET CONTROL ZONE 2 OF 4 (MOUSE ONLY)**
Execution:
```{r cache = TRUE, message = FALSE, warning = FALSE}
tT000 <- M2H(tT000M)
tT008 <- M2H(tT008M)
tT011 <- M2H(tT011M)
tT014 <- M2H(tT014M)
tT020 <- M2H(tT020M)
```

Note: Some gene IDs appear in the results as GeneName1///GeneName2///GeneName3///. I noticed these were not successfully converted to human genes. I performed a test on one such gene where I ran each GeneName individually, and no results were found either, so I conclude homologous genes are not available for those entries regardless of any formatting issue.
Record of this Test:
```{r eval=FALSE}
M1Test = c("LOC100503923","Gm15433","LOC100041903","Gm2666","Gm7609","Csprs")
M1Test
dfM1Test = mouse2human(M1Test)
dfM1Test #0 Results
```


**DATASET CONTROL ZONE 3 OF 4**
Write to files
```{r message = FALSE, warning=FALSE}
#Human:
write.table(tT009, file="tT009.txt", row.names=F, sep="\t")
write.table(tT023, file="tT023.txt", row.names=F, sep="\t")
write.table(tT036, file="tT036.txt", row.names=F, sep="\t")
write.table(tT044, file="tT044.txt", row.names=F, sep="\t")
#Mouse:
write.table(tT000, file="tT000.txt", row.names=F, sep="\t")
write.table(tT008, file="tT008.txt", row.names=F, sep="\t")
write.table(tT011, file="tT011.txt", row.names=F, sep="\t")
write.table(tT014, file="tT014.txt", row.names=F, sep="\t")
write.table(tT020, file="tT020.txt", row.names=F, sep="\t")
```

# 4. Calculate Counts Across Datasets (Python)
Define Reader Function
```{python}
def file_to_dict(file_name):
    file = open(file_name)
    header = file.readline()
    for line in file:
      row = line.strip().replace('"', '').split('\t')
      logFC = float(row[5])
      geneID = row[6]
      if logFC > 0:
        if geneID in young_dict:
          young_dict[geneID] += 1
          total_dict[geneID] += 1
        elif geneID in total_dict:
          total_dict[geneID] += 1
          young_dict[geneID] = 1
        else:
          young_dict[geneID] = 1
          total_dict[geneID] = 1
      if logFC < 0:
        if geneID in old_dict:
          old_dict[geneID] += 1
          total_dict[geneID] += (-1)
        elif geneID in total_dict:
          total_dict[geneID] += (-1)
          old_dict[geneID] = 1
        else:
          old_dict[geneID] = 1
          total_dict[geneID] = -1
    file.close()
```

**DATASET CONTROL ZONE 4 OF 4**
*(Exclude datasets from counts by commenting out here.)*
Execute Reader Function
```{python}
young_dict = {}
old_dict = {}
total_dict = {}

#Human
file_to_dict('tT009.txt')
file_to_dict('tT023.txt')
file_to_dict('tT036.txt')
file_to_dict('tT044.txt')

#Mouse
file_to_dict('tT000.txt')
file_to_dict('tT008.txt')
file_to_dict('tT011.txt')
file_to_dict('tT014.txt')
file_to_dict('tT020.txt')

```
**RESULTS**
Convert count dictionary to ordered dataframe
```{python}
total_df = pd.DataFrame.from_dict(total_dict, orient='index')
ordered_df = total_df.sort_values(by=0, ascending=False)
ordered_df
```
Record dataframes for separate young and old counts too
```{python}
young_df = pd.DataFrame.from_dict(young_dict, orient='index')
young_counts = young_df.sort_values(by=0, ascending=False)
young_counts

old_df = pd.DataFrame.from_dict(old_dict, orient='index')
old_counts = old_df.sort_values(by=0, ascending=False)
old_counts
```
Export all counts to CSV files
```{python}
ordered_df.to_csv("Total_Counts.csv")
young_counts.to_csv("Young_Counts.csv")
old_counts.to_csv("Old_Counts.csv")
```

# 5. Post-Count Analysis (R)
Import counts data and arrange in various dataframes and lists
```{r}
TotalCounts_byGene <- read.csv("Total_Counts.csv")
colnames(TotalCounts_byGene)<-c("Gene","Total_Count")
TotalCounts_numbers <- TotalCounts_byGene[,2]

TC2 <- TotalCounts_byGene[which(TotalCounts_byGene$Total_Count > 1 | TotalCounts_byGene$Total_Count < -1),]

YoungCounts_byGene <- read.csv("Young_Counts.csv")
YoungCounts_numbers <- YoungCounts_byGene[,2]
colnames(YoungCounts_byGene)<-c("Gene","Young_Count")

#adjust HERE to change histogram left limit (1 of 2):
YC2 <- YoungCounts_byGene[which(YoungCounts_byGene$Young_Count > 1),]
YC2L <- YC2[,2]

OldCounts_byGene <- read.csv("Old_Counts.csv")
OldCounts_numbers <- OldCounts_byGene[,2]
colnames(OldCounts_byGene)<-c("Gene","Old_Count")

#adjust HERE to change histogram left limit (2 of 2):
OC2 <- OldCounts_byGene[which(OldCounts_byGene$Old_Count > 1),]
OC2L <- OC2[,2]

YC2$Type <- "Young"
OC2$Type <- "Old"
colnames(YC2) <- c("Gene", "Count", "Type")
colnames(OC2) <- c("Gene", "Count", "Type")
HistoCounts <- rbind(YC2, OC2)
```

Histogram of counts
```{r}
ggplot(HistoCounts, aes(Count, fill = Type)) +
  geom_histogram(alpha = 0.5, color = "black", binwidth = 1, position = "identity") +
  theme_minimal()

ggplot
```

# 6. Dataset Characteristics

Number of DEGs per dataset
```{r}
DS <- read.csv("221_Datasets.csv")
boxplot(DS$DEGs, horizontal=TRUE, main="Number of DEGs per Dataset")
text(x=fivenum(DS$DEGs), labels =fivenum(DS$DEGs), y=1.25)
#Note the middle value is median (50th percentile), not mean.
#Lower hinge is 25th percentile, upper is 75th percentile

```


